/*
Copyright 2025 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package deepcopy

import (
	"bytes"
	"strings"
	"testing"
	"unsafe"

	"golang.org/x/tools/go/packages"
	"sigs.k8s.io/controller-tools/pkg/loader"
)

func TestWriteHeader(t *testing.T) {
	// Use unsafe to set the private imports field on the importsList's pkg to avoid needing a loader
	type packageHack struct {
		*packages.Package
		imports map[string]*loader.Package
	}

	tests := []struct {
		name        string
		packageName string
		imports     *importsList
		headerText  string
		wantImport  bool
	}{
		{
			name:        "no imports should not generate import block",
			packageName: "testpkg",
			imports: &importsList{
				byPath:  make(map[string]string),
				byAlias: make(map[string]string),
				pkg: &loader.Package{
					Package: &packages.Package{},
				},
			},
			headerText: "",
		},
		{
			name:        "with imports should generate import block",
			packageName: "testpkg",
			imports: &importsList{
				byPath: map[string]string{
					"fmt": "fmt",
				},
				byAlias: map[string]string{
					"fmt": "fmt",
				},
				pkg: &loader.Package{
					Package: &packages.Package{
						Imports: map[string]*packages.Package{
							"fmt": {Name: "fmt"},
						},
					},
				},
			},
			headerText: "",
			wantImport: true,
		},
		{
			name:        "no imports with header text",
			packageName: "testpkg",
			imports: &importsList{
				byPath:  make(map[string]string),
				byAlias: make(map[string]string),
				pkg: &loader.Package{
					Package: &packages.Package{},
				},
			},
			headerText: "// Copyright header\n",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var buf bytes.Buffer
			pkg := &loader.Package{
				Package: &packages.Package{},
			}
			pkgImportsMap := make(map[string]*loader.Package)
			// For the with imports test case, populate the imports map
			if len(tt.imports.byPath) > 0 {
				for path := range tt.imports.byPath {
					pkgImportsMap[path] = &loader.Package{
						Package: &packages.Package{Name: tt.imports.byPath[path]},
					}
				}
			}
			(*packageHack)(unsafe.Pointer(tt.imports.pkg)).imports = pkgImportsMap

			writeHeader(pkg, &buf, tt.packageName, tt.imports, tt.headerText)

			output := buf.String()

			// Check for empty import block "import ()"
			if strings.Contains(output, "import ()") {
				t.Error("generated code contains empty import block 'import ()'")
			}

			// Check if import block exists
			hasImport := strings.Contains(output, "import (")
			if hasImport != tt.wantImport {
				t.Errorf("import block presence = %v, want %v\nOutput:\n%s", hasImport, tt.wantImport, output)
			}

			// Verify package declaration exists
			if !strings.Contains(output, "package "+tt.packageName) {
				t.Errorf("missing package declaration, got:\n%s", output)
			}

			// Verify build tag exists
			if !strings.Contains(output, "//go:build !ignore_autogenerated") {
				t.Errorf("missing build tag, got:\n%s", output)
			}

			// Verify header text if provided
			if tt.headerText != "" && !strings.Contains(output, tt.headerText) {
				t.Errorf("missing header text, got:\n%s", output)
			}
		})
	}
}
