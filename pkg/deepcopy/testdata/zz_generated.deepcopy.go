// +build !ignore_autogenerated

// Code generated by controller-gen. DO NOT EDIT.

package cronjob

import (
	"encoding/json"
	"k8s.io/api/core/v1"
	runtime "k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in AliasMap) DeepCopyInto(out *AliasMap) {
	{
		in := &in
		*out = make(AliasMap, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AliasMap.
func (in AliasMap) DeepCopy() AliasMap {
	if in == nil {
		return nil
	}
	out := new(AliasMap)
	in.DeepCopyInto(out)
	return *out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in AliasSlice) DeepCopyInto(out *AliasSlice) {
	{
		in := &in
		*out = make(AliasSlice, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AliasSlice.
func (in AliasSlice) DeepCopy() AliasSlice {
	if in == nil {
		return nil
	}
	out := new(AliasSlice)
	in.DeepCopyInto(out)
	return *out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AliasStruct) DeepCopyInto(out *AliasStruct) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AliasStruct.
func (in *AliasStruct) DeepCopy() *AliasStruct {
	if in == nil {
		return nil
	}
	out := new(AliasStruct)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BadDeepCopyHasParams) DeepCopyInto(out *BadDeepCopyHasParams) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BadDeepCopyHasParams.
func (in *BadDeepCopyHasParams) DeepCopy() *BadDeepCopyHasParams {
	if in == nil {
		return nil
	}
	out := new(BadDeepCopyHasParams)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BadDeepCopyIntoHasResult) DeepCopyInto(out *BadDeepCopyIntoHasResult) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BadDeepCopyIntoHasResult.
func (in *BadDeepCopyIntoHasResult) DeepCopy() *BadDeepCopyIntoHasResult {
	if in == nil {
		return nil
	}
	out := new(BadDeepCopyIntoHasResult)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BadDeepCopyIntoNoParams) DeepCopyInto(out *BadDeepCopyIntoNoParams) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BadDeepCopyIntoNoParams.
func (in *BadDeepCopyIntoNoParams) DeepCopy() *BadDeepCopyIntoNoParams {
	if in == nil {
		return nil
	}
	out := new(BadDeepCopyIntoNoParams)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BadDeepCopyIntoNonPtrParam) DeepCopyInto(out *BadDeepCopyIntoNonPtrParam) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BadDeepCopyIntoNonPtrParam.
func (in *BadDeepCopyIntoNonPtrParam) DeepCopy() *BadDeepCopyIntoNonPtrParam {
	if in == nil {
		return nil
	}
	out := new(BadDeepCopyIntoNonPtrParam)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BadDeepCopyNoReturn) DeepCopyInto(out *BadDeepCopyNoReturn) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BadDeepCopyNoReturn.
func (in *BadDeepCopyNoReturn) DeepCopy() *BadDeepCopyNoReturn {
	if in == nil {
		return nil
	}
	out := new(BadDeepCopyNoReturn)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BadDeepCopyNonPtrVal) DeepCopyInto(out *BadDeepCopyNonPtrVal) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BadDeepCopyNonPtrVal.
func (in *BadDeepCopyNonPtrVal) DeepCopy() *BadDeepCopyNonPtrVal {
	if in == nil {
		return nil
	}
	out := new(BadDeepCopyNonPtrVal)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BadDeepCopyPtrMismatch) DeepCopyInto(out *BadDeepCopyPtrMismatch) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BadDeepCopyPtrMismatch.
func (in *BadDeepCopyPtrMismatch) DeepCopy() *BadDeepCopyPtrMismatch {
	if in == nil {
		return nil
	}
	out := new(BadDeepCopyPtrMismatch)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BadDeepCopyPtrVal) DeepCopyInto(out *BadDeepCopyPtrVal) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BadDeepCopyPtrVal.
func (in *BadDeepCopyPtrVal) DeepCopy() *BadDeepCopyPtrVal {
	if in == nil {
		return nil
	}
	out := new(BadDeepCopyPtrVal)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CronJob) DeepCopyInto(out *CronJob) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CronJob.
func (in *CronJob) DeepCopy() *CronJob {
	if in == nil {
		return nil
	}
	out := new(CronJob)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *CronJob) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CronJobList) DeepCopyInto(out *CronJobList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]CronJob, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CronJobList.
func (in *CronJobList) DeepCopy() *CronJobList {
	if in == nil {
		return nil
	}
	out := new(CronJobList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *CronJobList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CronJobSpec) DeepCopyInto(out *CronJobSpec) {
	*out = *in
	if in.StartingDeadlineSeconds != nil {
		in, out := &in.StartingDeadlineSeconds, &out.StartingDeadlineSeconds
		*out = new(int64)
		**out = **in
	}
	if in.Suspend != nil {
		in, out := &in.Suspend, &out.Suspend
		*out = new(bool)
		**out = **in
	}
	in.JobTemplate.DeepCopyInto(&out.JobTemplate)
	if in.SuccessfulJobsHistoryLimit != nil {
		in, out := &in.SuccessfulJobsHistoryLimit, &out.SuccessfulJobsHistoryLimit
		*out = new(int32)
		**out = **in
	}
	if in.FailedJobsHistoryLimit != nil {
		in, out := &in.FailedJobsHistoryLimit, &out.FailedJobsHistoryLimit
		*out = new(int32)
		**out = **in
	}
	in.SpecificCases.DeepCopyInto(&out.SpecificCases)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CronJobSpec.
func (in *CronJobSpec) DeepCopy() *CronJobSpec {
	if in == nil {
		return nil
	}
	out := new(CronJobSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CronJobStatus) DeepCopyInto(out *CronJobStatus) {
	*out = *in
	if in.Active != nil {
		in, out := &in.Active, &out.Active
		*out = make([]v1.ObjectReference, len(*in))
		copy(*out, *in)
	}
	if in.LastScheduleTime != nil {
		in, out := &in.LastScheduleTime, &out.LastScheduleTime
		*out = (*in).DeepCopy()
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CronJobStatus.
func (in *CronJobStatus) DeepCopy() *CronJobStatus {
	if in == nil {
		return nil
	}
	out := new(CronJobStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DeepCopyIntoNonPtr.
func (in *DeepCopyIntoNonPtr) DeepCopy() *DeepCopyIntoNonPtr {
	if in == nil {
		return nil
	}
	out := new(DeepCopyIntoNonPtr)
	in.DeepCopyInto(out)
	return out
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DeepCopyIntoPtr.
func (in *DeepCopyIntoPtr) DeepCopy() *DeepCopyIntoPtr {
	if in == nil {
		return nil
	}
	out := new(DeepCopyIntoPtr)
	in.DeepCopyInto(out)
	return out
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DeepCopyIntoRef.
func (in DeepCopyIntoRef) DeepCopy() DeepCopyIntoRef {
	if in == nil {
		return nil
	}
	out := new(DeepCopyIntoRef)
	in.DeepCopyInto(out)
	return *out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DeepCopyNonPtr) DeepCopyInto(out *DeepCopyNonPtr) {
	*out = in.DeepCopy()
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DeepCopyPtr) DeepCopyInto(out *DeepCopyPtr) {
	clone := in.DeepCopy()
	*out = *clone
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Foo) DeepCopyInto(out *Foo) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Foo.
func (in *Foo) DeepCopy() *Foo {
	if in == nil {
		return nil
	}
	out := new(Foo)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Foo) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FooAlias) DeepCopyInto(out *FooAlias) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FooAlias.
func (in *FooAlias) DeepCopy() *FooAlias {
	if in == nil {
		return nil
	}
	out := new(FooAlias)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in FooMap) DeepCopyInto(out *FooMap) {
	{
		in := &in
		*out = make(FooMap, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FooMap.
func (in FooMap) DeepCopy() FooMap {
	if in == nil {
		return nil
	}
	out := new(FooMap)
	in.DeepCopyInto(out)
	return *out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in FooSlice) DeepCopyInto(out *FooSlice) {
	{
		in := &in
		*out = make(FooSlice, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FooSlice.
func (in FooSlice) DeepCopy() FooSlice {
	if in == nil {
		return nil
	}
	out := new(FooSlice)
	in.DeepCopyInto(out)
	return *out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Inner) DeepCopyInto(out *Inner) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Inner.
func (in *Inner) DeepCopy() *Inner {
	if in == nil {
		return nil
	}
	out := new(Inner)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in ManualSlice) DeepCopyInto(out *ManualSlice) {
	{
		in := &in
		*out = in.DeepCopy()
	}
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ManualStruct) DeepCopyInto(out *ManualStruct) {
	*out = in.DeepCopy()
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ManualStruct_Alias) DeepCopyInto(out *ManualStruct_Alias) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ManualStruct_Alias.
func (in *ManualStruct_Alias) DeepCopy() *ManualStruct_Alias {
	if in == nil {
		return nil
	}
	out := new(ManualStruct_Alias)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in Map) DeepCopyInto(out *Map) {
	{
		in := &in
		*out = make(Map, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Map.
func (in Map) DeepCopy() Map {
	if in == nil {
		return nil
	}
	out := new(Map)
	in.DeepCopyInto(out)
	return *out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in MapOfStrings) DeepCopyInto(out *MapOfStrings) {
	{
		in := &in
		*out = make(MapOfStrings, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MapOfStrings.
func (in MapOfStrings) DeepCopy() MapOfStrings {
	if in == nil {
		return nil
	}
	out := new(MapOfStrings)
	in.DeepCopyInto(out)
	return *out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in Slice) DeepCopyInto(out *Slice) {
	{
		in := &in
		*out = make(Slice, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Slice.
func (in Slice) DeepCopy() Slice {
	if in == nil {
		return nil
	}
	out := new(Slice)
	in.DeepCopyInto(out)
	return *out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in SliceOfPointers) DeepCopyInto(out *SliceOfPointers) {
	{
		in := &in
		*out = make(SliceOfPointers, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(SomeStruct)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SliceOfPointers.
func (in SliceOfPointers) DeepCopy() SliceOfPointers {
	if in == nil {
		return nil
	}
	out := new(SliceOfPointers)
	in.DeepCopyInto(out)
	return *out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SomeStruct) DeepCopyInto(out *SomeStruct) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SomeStruct.
func (in *SomeStruct) DeepCopy() *SomeStruct {
	if in == nil {
		return nil
	}
	out := new(SomeStruct)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SpecificCases) DeepCopyInto(out *SpecificCases) {
	*out = *in
	in.ManualDeepCopyPtr.DeepCopyInto(&out.ManualDeepCopyPtr)
	out.ManualDeepCopyNonPtr = in.ManualDeepCopyNonPtr.DeepCopy()
	in.ManualIntoPtr.DeepCopyInto(&out.ManualIntoPtr)
	in.ManualIntoNonPtr.DeepCopyInto(&out.ManualIntoNonPtr)
	out.BadDeepCopyHasParams = in.BadDeepCopyHasParams
	out.BadDeepCopyNoReturn = in.BadDeepCopyNoReturn
	out.BadDeepCopyPtrVal = in.BadDeepCopyPtrVal
	out.BadDeepCopyNonPtrVal = in.BadDeepCopyNonPtrVal
	out.BadDeepCopyPtrMismatch = in.BadDeepCopyPtrMismatch
	out.BadDeepCopyIntoNoParams = in.BadDeepCopyIntoNoParams
	out.BadDeepCopyIntoNonPtrParam = in.BadDeepCopyIntoNonPtrParam
	out.BadDeepCopyIntoHasResult = in.BadDeepCopyIntoHasResult
	if in.MapInField != nil {
		in, out := &in.MapInField, &out.MapInField
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SliceInField != nil {
		in, out := &in.SliceInField, &out.SliceInField
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.BuiltInPointer != nil {
		in, out := &in.BuiltInPointer, &out.BuiltInPointer
		*out = new(string)
		**out = **in
	}
	if in.MapToDeepCopyPtr != nil {
		in, out := &in.MapToDeepCopyPtr, &out.MapToDeepCopyPtr
		*out = make(map[string]DeepCopyPtr, len(*in))
		for key, val := range *in {
			(*out)[key] = *val.DeepCopy()
		}
	}
	if in.MapToDeepCopyNonPtr != nil {
		in, out := &in.MapToDeepCopyNonPtr, &out.MapToDeepCopyNonPtr
		*out = make(map[string]DeepCopyPtr, len(*in))
		for key, val := range *in {
			(*out)[key] = *val.DeepCopy()
		}
	}
	if in.MapToDeepCopyIntoPtr != nil {
		in, out := &in.MapToDeepCopyIntoPtr, &out.MapToDeepCopyIntoPtr
		*out = make(map[string]DeepCopyIntoPtr, len(*in))
		for key, val := range *in {
			(*out)[key] = *val.DeepCopy()
		}
	}
	if in.MapToDeepCopyIntoNonPtr != nil {
		in, out := &in.MapToDeepCopyIntoNonPtr, &out.MapToDeepCopyIntoNonPtr
		*out = make(map[string]DeepCopyIntoNonPtr, len(*in))
		for key, val := range *in {
			(*out)[key] = *val.DeepCopy()
		}
	}
	if in.MapToShallowNamedType != nil {
		in, out := &in.MapToShallowNamedType, &out.MapToShallowNamedType
		*out = make(map[string]TotallyAString, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.MapToReferenceType != nil {
		in, out := &in.MapToReferenceType, &out.MapToReferenceType
		*out = make(map[string][]string, len(*in))
		for key, val := range *in {
			var outVal []string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = make([]string, len(*in))
				copy(*out, *in)
			}
			(*out)[key] = outVal
		}
	}
	if in.MapToStruct != nil {
		in, out := &in.MapToStruct, &out.MapToStruct
		*out = make(map[string]CronJobSpec, len(*in))
		for key, val := range *in {
			(*out)[key] = *val.DeepCopy()
		}
	}
	if in.MapWithNamedKeys != nil {
		in, out := &in.MapWithNamedKeys, &out.MapWithNamedKeys
		*out = make(map[TotallyAString]int, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.MapToPtrToDeepCopyIntoRefType != nil {
		in, out := &in.MapToPtrToDeepCopyIntoRefType, &out.MapToPtrToDeepCopyIntoRefType
		*out = make(map[string]*DeepCopyIntoRef, len(*in))
		for key, val := range *in {
			{
				x := val.DeepCopy()
				(*out)[key] = &x
			}
		}
	}
	if in.MapToDeepCopyIntoRefType != nil {
		in, out := &in.MapToDeepCopyIntoRefType, &out.MapToDeepCopyIntoRefType
		*out = make(map[string]DeepCopyIntoRef, len(*in))
		for key, val := range *in {
			(*out)[key] = val.DeepCopy()
		}
	}
	if in.SliceToDeepCopyPtr != nil {
		in, out := &in.SliceToDeepCopyPtr, &out.SliceToDeepCopyPtr
		*out = make([]DeepCopyPtr, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.SliceToDeepCopyNonPtr != nil {
		in, out := &in.SliceToDeepCopyNonPtr, &out.SliceToDeepCopyNonPtr
		*out = make([]DeepCopyPtr, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.SliceToDeepCopyIntoPtr != nil {
		in, out := &in.SliceToDeepCopyIntoPtr, &out.SliceToDeepCopyIntoPtr
		*out = make([]DeepCopyIntoPtr, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.SliceToDeepCopyIntoNonPtr != nil {
		in, out := &in.SliceToDeepCopyIntoNonPtr, &out.SliceToDeepCopyIntoNonPtr
		*out = make([]DeepCopyIntoNonPtr, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.SliceToShallowNamedType != nil {
		in, out := &in.SliceToShallowNamedType, &out.SliceToShallowNamedType
		*out = make([]TotallyAString, len(*in))
		copy(*out, *in)
	}
	if in.SliceToReferenceType != nil {
		in, out := &in.SliceToReferenceType, &out.SliceToReferenceType
		*out = make([][]string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = make([]string, len(*in))
				copy(*out, *in)
			}
		}
	}
	if in.SliceToStruct != nil {
		in, out := &in.SliceToStruct, &out.SliceToStruct
		*out = make([]CronJobSpec, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.PtrToDeepCopyPtr != nil {
		in, out := &in.PtrToDeepCopyPtr, &out.PtrToDeepCopyPtr
		*out = (*in).DeepCopy()
	}
	if in.PtrToDeepCopyNonPtr != nil {
		in, out := &in.PtrToDeepCopyNonPtr, &out.PtrToDeepCopyNonPtr
		*out = (*in).DeepCopy()
	}
	if in.PtrToDeepCopyIntoPtr != nil {
		in, out := &in.PtrToDeepCopyIntoPtr, &out.PtrToDeepCopyIntoPtr
		*out = (*in).DeepCopy()
	}
	if in.PtrToDeepCopyIntoNonPtr != nil {
		in, out := &in.PtrToDeepCopyIntoNonPtr, &out.PtrToDeepCopyIntoNonPtr
		*out = (*in).DeepCopy()
	}
	if in.PtrToShallowNamedType != nil {
		in, out := &in.PtrToShallowNamedType, &out.PtrToShallowNamedType
		*out = new(TotallyAString)
		**out = **in
	}
	if in.PtrToReferenceType != nil {
		in, out := &in.PtrToReferenceType, &out.PtrToReferenceType
		*out = new([]string)
		if **in != nil {
			in, out := *in, *out
			*out = make([]string, len(*in))
			copy(*out, *in)
		}
	}
	if in.PtrToStruct != nil {
		in, out := &in.PtrToStruct, &out.PtrToStruct
		*out = new(CronJobSpec)
		(*in).DeepCopyInto(*out)
	}
	if in.PtrToDeepCopyIntoRef != nil {
		in, out := &in.PtrToDeepCopyIntoRef, &out.PtrToDeepCopyIntoRef
		x := (*in).DeepCopy()
		*out = &x
	}
	if in.SomePointers != nil {
		in, out := &in.SomePointers, &out.SomePointers
		*out = make(SliceOfPointers, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(SomeStruct)
				**out = **in
			}
		}
	}
	if in.StringMap != nil {
		in, out := &in.StringMap, &out.StringMap
		*out = make(MapOfStrings, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SpecificCases.
func (in *SpecificCases) DeepCopy() *SpecificCases {
	if in == nil {
		return nil
	}
	out := new(SpecificCases)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Struct) DeepCopyInto(out *Struct) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Struct.
func (in *Struct) DeepCopy() *Struct {
	if in == nil {
		return nil
	}
	out := new(Struct)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Struct_B) DeepCopyInto(out *Struct_B) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Struct_B.
func (in *Struct_B) DeepCopy() *Struct_B {
	if in == nil {
		return nil
	}
	out := new(Struct_B)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Struct_Embed_Int) DeepCopyInto(out *Struct_Embed_Int) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Struct_Embed_Int.
func (in *Struct_Embed_Int) DeepCopy() *Struct_Embed_Int {
	if in == nil {
		return nil
	}
	out := new(Struct_Embed_Int)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Struct_Embed_ManualStruct) DeepCopyInto(out *Struct_Embed_ManualStruct) {
	*out = *in
	out.ManualStruct = in.ManualStruct.DeepCopy()
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Struct_Embed_ManualStruct.
func (in *Struct_Embed_ManualStruct) DeepCopy() *Struct_Embed_ManualStruct {
	if in == nil {
		return nil
	}
	out := new(Struct_Embed_ManualStruct)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Struct_Embed_Pointer) DeepCopyInto(out *Struct_Embed_Pointer) {
	*out = *in
	if in.int != nil {
		in, out := &in.int, &out.int
		*out = new(int)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Struct_Embed_Pointer.
func (in *Struct_Embed_Pointer) DeepCopy() *Struct_Embed_Pointer {
	if in == nil {
		return nil
	}
	out := new(Struct_Embed_Pointer)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Struct_Embed_Struct_PrimitivePointers) DeepCopyInto(out *Struct_Embed_Struct_PrimitivePointers) {
	*out = *in
	in.Struct_PrimitivePointers.DeepCopyInto(&out.Struct_PrimitivePointers)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Struct_Embed_Struct_PrimitivePointers.
func (in *Struct_Embed_Struct_PrimitivePointers) DeepCopy() *Struct_Embed_Struct_PrimitivePointers {
	if in == nil {
		return nil
	}
	out := new(Struct_Embed_Struct_PrimitivePointers)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Struct_Embed_Struct_Primitives) DeepCopyInto(out *Struct_Embed_Struct_Primitives) {
	*out = *in
	out.Struct_Primitives = in.Struct_Primitives
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Struct_Embed_Struct_Primitives.
func (in *Struct_Embed_Struct_Primitives) DeepCopy() *Struct_Embed_Struct_Primitives {
	if in == nil {
		return nil
	}
	out := new(Struct_Embed_Struct_Primitives)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Struct_Embed_Struct_Slices) DeepCopyInto(out *Struct_Embed_Struct_Slices) {
	*out = *in
	in.Struct_Slices.DeepCopyInto(&out.Struct_Slices)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Struct_Embed_Struct_Slices.
func (in *Struct_Embed_Struct_Slices) DeepCopy() *Struct_Embed_Struct_Slices {
	if in == nil {
		return nil
	}
	out := new(Struct_Embed_Struct_Slices)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Struct_Empty) DeepCopyInto(out *Struct_Empty) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Struct_Empty.
func (in *Struct_Empty) DeepCopy() *Struct_Empty {
	if in == nil {
		return nil
	}
	out := new(Struct_Empty)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Struct_Everything) DeepCopyInto(out *Struct_Everything) {
	*out = *in
	out.StructField = in.StructField
	out.EmptyStructField = in.EmptyStructField
	out.ManualStructField = in.ManualStructField.DeepCopy()
	out.ManualStructAliasField = in.ManualStructAliasField
	if in.BoolPtrField != nil {
		in, out := &in.BoolPtrField, &out.BoolPtrField
		*out = new(bool)
		**out = **in
	}
	if in.IntPtrField != nil {
		in, out := &in.IntPtrField, &out.IntPtrField
		*out = new(int)
		**out = **in
	}
	if in.StringPtrField != nil {
		in, out := &in.StringPtrField, &out.StringPtrField
		*out = new(string)
		**out = **in
	}
	if in.FloatPtrField != nil {
		in, out := &in.FloatPtrField, &out.FloatPtrField
		*out = new(float64)
		**out = **in
	}
	in.PrimitivePointersField.DeepCopyInto(&out.PrimitivePointersField)
	if in.ManualStructPtrField != nil {
		in, out := &in.ManualStructPtrField, &out.ManualStructPtrField
		x := (*in).DeepCopy()
		*out = &x
	}
	if in.ManualStructAliasPtrField != nil {
		in, out := &in.ManualStructAliasPtrField, &out.ManualStructAliasPtrField
		*out = new(ManualStruct_Alias)
		**out = **in
	}
	if in.SliceBoolField != nil {
		in, out := &in.SliceBoolField, &out.SliceBoolField
		*out = make([]bool, len(*in))
		copy(*out, *in)
	}
	if in.SliceByteField != nil {
		in, out := &in.SliceByteField, &out.SliceByteField
		*out = make([]byte, len(*in))
		copy(*out, *in)
	}
	if in.SliceIntField != nil {
		in, out := &in.SliceIntField, &out.SliceIntField
		*out = make([]int, len(*in))
		copy(*out, *in)
	}
	if in.SliceStringField != nil {
		in, out := &in.SliceStringField, &out.SliceStringField
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.SliceFloatField != nil {
		in, out := &in.SliceFloatField, &out.SliceFloatField
		*out = make([]float64, len(*in))
		copy(*out, *in)
	}
	in.SlicesField.DeepCopyInto(&out.SlicesField)
	if in.SliceManualStructField != nil {
		in, out := &in.SliceManualStructField, &out.SliceManualStructField
		*out = make([]ManualStruct, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	out.ManualSliceField = in.ManualSliceField.DeepCopy()
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Struct_Everything.
func (in *Struct_Everything) DeepCopy() *Struct_Everything {
	if in == nil {
		return nil
	}
	out := new(Struct_Everything)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Struct_ExplicitObject) DeepCopyInto(out *Struct_ExplicitObject) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Struct_ExplicitObject.
func (in *Struct_ExplicitObject) DeepCopy() *Struct_ExplicitObject {
	if in == nil {
		return nil
	}
	out := new(Struct_ExplicitObject)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Struct_ExplicitObject) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Struct_ExplicitSelectorExplicitObject) DeepCopyInto(out *Struct_ExplicitSelectorExplicitObject) {
	*out = *in
	out.Struct_TypeMeta = in.Struct_TypeMeta
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Struct_ExplicitSelectorExplicitObject.
func (in *Struct_ExplicitSelectorExplicitObject) DeepCopy() *Struct_ExplicitSelectorExplicitObject {
	if in == nil {
		return nil
	}
	out := new(Struct_ExplicitSelectorExplicitObject)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Struct_ExplicitSelectorExplicitObject) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Struct_PrimitivePointers) DeepCopyInto(out *Struct_PrimitivePointers) {
	*out = *in
	if in.BoolPtrField != nil {
		in, out := &in.BoolPtrField, &out.BoolPtrField
		*out = new(bool)
		**out = **in
	}
	if in.IntPtrField != nil {
		in, out := &in.IntPtrField, &out.IntPtrField
		*out = new(int)
		**out = **in
	}
	if in.StringPtrField != nil {
		in, out := &in.StringPtrField, &out.StringPtrField
		*out = new(string)
		**out = **in
	}
	if in.FloatPtrField != nil {
		in, out := &in.FloatPtrField, &out.FloatPtrField
		*out = new(float64)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Struct_PrimitivePointers.
func (in *Struct_PrimitivePointers) DeepCopy() *Struct_PrimitivePointers {
	if in == nil {
		return nil
	}
	out := new(Struct_PrimitivePointers)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Struct_PrimitivePointers_Alias) DeepCopyInto(out *Struct_PrimitivePointers_Alias) {
	*out = *in
	if in.BoolPtrField != nil {
		in, out := &in.BoolPtrField, &out.BoolPtrField
		*out = new(bool)
		**out = **in
	}
	if in.IntPtrField != nil {
		in, out := &in.IntPtrField, &out.IntPtrField
		*out = new(int)
		**out = **in
	}
	if in.StringPtrField != nil {
		in, out := &in.StringPtrField, &out.StringPtrField
		*out = new(string)
		**out = **in
	}
	if in.FloatPtrField != nil {
		in, out := &in.FloatPtrField, &out.FloatPtrField
		*out = new(float64)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Struct_PrimitivePointers_Alias.
func (in *Struct_PrimitivePointers_Alias) DeepCopy() *Struct_PrimitivePointers_Alias {
	if in == nil {
		return nil
	}
	out := new(Struct_PrimitivePointers_Alias)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Struct_Primitives) DeepCopyInto(out *Struct_Primitives) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Struct_Primitives.
func (in *Struct_Primitives) DeepCopy() *Struct_Primitives {
	if in == nil {
		return nil
	}
	out := new(Struct_Primitives)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Struct_Primitives_Alias) DeepCopyInto(out *Struct_Primitives_Alias) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Struct_Primitives_Alias.
func (in *Struct_Primitives_Alias) DeepCopy() *Struct_Primitives_Alias {
	if in == nil {
		return nil
	}
	out := new(Struct_Primitives_Alias)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Struct_Slices) DeepCopyInto(out *Struct_Slices) {
	*out = *in
	if in.SliceBoolField != nil {
		in, out := &in.SliceBoolField, &out.SliceBoolField
		*out = make([]bool, len(*in))
		copy(*out, *in)
	}
	if in.SliceByteField != nil {
		in, out := &in.SliceByteField, &out.SliceByteField
		*out = make([]byte, len(*in))
		copy(*out, *in)
	}
	if in.SliceIntField != nil {
		in, out := &in.SliceIntField, &out.SliceIntField
		*out = make([]int, len(*in))
		copy(*out, *in)
	}
	if in.SliceStringField != nil {
		in, out := &in.SliceStringField, &out.SliceStringField
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.SliceFloatField != nil {
		in, out := &in.SliceFloatField, &out.SliceFloatField
		*out = make([]float64, len(*in))
		copy(*out, *in)
	}
	if in.SliceStructPrimitivesField != nil {
		in, out := &in.SliceStructPrimitivesField, &out.SliceStructPrimitivesField
		*out = make([]Struct_Primitives, len(*in))
		copy(*out, *in)
	}
	if in.SliceStructPrimitivesAliasField != nil {
		in, out := &in.SliceStructPrimitivesAliasField, &out.SliceStructPrimitivesAliasField
		*out = make([]Struct_Primitives_Alias, len(*in))
		copy(*out, *in)
	}
	if in.SliceStructPrimitivePointersField != nil {
		in, out := &in.SliceStructPrimitivePointersField, &out.SliceStructPrimitivePointersField
		*out = make([]Struct_PrimitivePointers, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.SliceStructPrimitivePointersAliasField != nil {
		in, out := &in.SliceStructPrimitivePointersAliasField, &out.SliceStructPrimitivePointersAliasField
		*out = make([]Struct_PrimitivePointers_Alias, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.SliceSliceIntField != nil {
		in, out := &in.SliceSliceIntField, &out.SliceSliceIntField
		*out = make([][]int, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = make([]int, len(*in))
				copy(*out, *in)
			}
		}
	}
	if in.SliceManualStructField != nil {
		in, out := &in.SliceManualStructField, &out.SliceManualStructField
		*out = make([]ManualStruct, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	out.ManualSliceField = in.ManualSliceField.DeepCopy()
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Struct_Slices.
func (in *Struct_Slices) DeepCopy() *Struct_Slices {
	if in == nil {
		return nil
	}
	out := new(Struct_Slices)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Struct_Slices_Alias) DeepCopyInto(out *Struct_Slices_Alias) {
	*out = *in
	if in.SliceBoolField != nil {
		in, out := &in.SliceBoolField, &out.SliceBoolField
		*out = make([]bool, len(*in))
		copy(*out, *in)
	}
	if in.SliceByteField != nil {
		in, out := &in.SliceByteField, &out.SliceByteField
		*out = make([]byte, len(*in))
		copy(*out, *in)
	}
	if in.SliceIntField != nil {
		in, out := &in.SliceIntField, &out.SliceIntField
		*out = make([]int, len(*in))
		copy(*out, *in)
	}
	if in.SliceStringField != nil {
		in, out := &in.SliceStringField, &out.SliceStringField
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.SliceFloatField != nil {
		in, out := &in.SliceFloatField, &out.SliceFloatField
		*out = make([]float64, len(*in))
		copy(*out, *in)
	}
	if in.SliceStructPrimitivesField != nil {
		in, out := &in.SliceStructPrimitivesField, &out.SliceStructPrimitivesField
		*out = make([]Struct_Primitives, len(*in))
		copy(*out, *in)
	}
	if in.SliceStructPrimitivesAliasField != nil {
		in, out := &in.SliceStructPrimitivesAliasField, &out.SliceStructPrimitivesAliasField
		*out = make([]Struct_Primitives_Alias, len(*in))
		copy(*out, *in)
	}
	if in.SliceStructPrimitivePointersField != nil {
		in, out := &in.SliceStructPrimitivePointersField, &out.SliceStructPrimitivePointersField
		*out = make([]Struct_PrimitivePointers, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.SliceStructPrimitivePointersAliasField != nil {
		in, out := &in.SliceStructPrimitivePointersAliasField, &out.SliceStructPrimitivePointersAliasField
		*out = make([]Struct_PrimitivePointers_Alias, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.SliceSliceIntField != nil {
		in, out := &in.SliceSliceIntField, &out.SliceSliceIntField
		*out = make([][]int, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = make([]int, len(*in))
				copy(*out, *in)
			}
		}
	}
	if in.SliceManualStructField != nil {
		in, out := &in.SliceManualStructField, &out.SliceManualStructField
		*out = make([]ManualStruct, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	out.ManualSliceField = in.ManualSliceField.DeepCopy()
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Struct_Slices_Alias.
func (in *Struct_Slices_Alias) DeepCopy() *Struct_Slices_Alias {
	if in == nil {
		return nil
	}
	out := new(Struct_Slices_Alias)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Struct_Struct_PrimitivePointers) DeepCopyInto(out *Struct_Struct_PrimitivePointers) {
	*out = *in
	in.StructField.DeepCopyInto(&out.StructField)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Struct_Struct_PrimitivePointers.
func (in *Struct_Struct_PrimitivePointers) DeepCopy() *Struct_Struct_PrimitivePointers {
	if in == nil {
		return nil
	}
	out := new(Struct_Struct_PrimitivePointers)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Struct_Struct_Primitives) DeepCopyInto(out *Struct_Struct_Primitives) {
	*out = *in
	out.StructField = in.StructField
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Struct_Struct_Primitives.
func (in *Struct_Struct_Primitives) DeepCopy() *Struct_Struct_Primitives {
	if in == nil {
		return nil
	}
	out := new(Struct_Struct_Primitives)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Struct_Struct_Slices) DeepCopyInto(out *Struct_Struct_Slices) {
	*out = *in
	in.StructField.DeepCopyInto(&out.StructField)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Struct_Struct_Slices.
func (in *Struct_Struct_Slices) DeepCopy() *Struct_Struct_Slices {
	if in == nil {
		return nil
	}
	out := new(Struct_Struct_Slices)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TestBuiltins) DeepCopyInto(out *TestBuiltins) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TestBuiltins.
func (in *TestBuiltins) DeepCopy() *TestBuiltins {
	if in == nil {
		return nil
	}
	out := new(TestBuiltins)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TestInner) DeepCopyInto(out *TestInner) {
	*out = *in
	out.Inner1 = in.Inner1
	out.Inner2 = in.Inner2
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TestInner.
func (in *TestInner) DeepCopy() *TestInner {
	if in == nil {
		return nil
	}
	out := new(TestInner)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TestMaps) DeepCopyInto(out *TestMaps) {
	*out = *in
	if in.Byte != nil {
		in, out := &in.Byte, &out.Byte
		*out = make(map[string]byte, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Int8 != nil {
		in, out := &in.Int8, &out.Int8
		*out = make(map[string]int8, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Int16 != nil {
		in, out := &in.Int16, &out.Int16
		*out = make(map[string]int16, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Int32 != nil {
		in, out := &in.Int32, &out.Int32
		*out = make(map[string]int32, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Int64 != nil {
		in, out := &in.Int64, &out.Int64
		*out = make(map[string]int64, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Uint8 != nil {
		in, out := &in.Uint8, &out.Uint8
		*out = make(map[string]uint8, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Uint16 != nil {
		in, out := &in.Uint16, &out.Uint16
		*out = make(map[string]uint16, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Uint32 != nil {
		in, out := &in.Uint32, &out.Uint32
		*out = make(map[string]uint32, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Uint64 != nil {
		in, out := &in.Uint64, &out.Uint64
		*out = make(map[string]uint64, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Float32 != nil {
		in, out := &in.Float32, &out.Float32
		*out = make(map[string]float32, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Float64 != nil {
		in, out := &in.Float64, &out.Float64
		*out = make(map[string]float64, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.String != nil {
		in, out := &in.String, &out.String
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.StringPtr != nil {
		in, out := &in.StringPtr, &out.StringPtr
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.StringPtrPtr != nil {
		in, out := &in.StringPtrPtr, &out.StringPtrPtr
		*out = make(map[string]**string, len(*in))
		for key, val := range *in {
			var outVal **string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(*string)
				if **in != nil {
					in, out := *in, *out
					*out = new(string)
					**out = **in
				}
			}
			(*out)[key] = outVal
		}
	}
	if in.Map != nil {
		in, out := &in.Map, &out.Map
		*out = make(map[string]map[string]string, len(*in))
		for key, val := range *in {
			var outVal map[string]string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = make(map[string]string, len(*in))
				for key, val := range *in {
					(*out)[key] = val
				}
			}
			(*out)[key] = outVal
		}
	}
	if in.MapPtr != nil {
		in, out := &in.MapPtr, &out.MapPtr
		*out = make(map[string]*map[string]string, len(*in))
		for key, val := range *in {
			var outVal *map[string]string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(map[string]string)
				if **in != nil {
					in, out := *in, *out
					*out = make(map[string]string, len(*in))
					for key, val := range *in {
						(*out)[key] = val
					}
				}
			}
			(*out)[key] = outVal
		}
	}
	if in.Slice != nil {
		in, out := &in.Slice, &out.Slice
		*out = make(map[string][]string, len(*in))
		for key, val := range *in {
			var outVal []string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = make([]string, len(*in))
				copy(*out, *in)
			}
			(*out)[key] = outVal
		}
	}
	if in.SlicePtr != nil {
		in, out := &in.SlicePtr, &out.SlicePtr
		*out = make(map[string]*[]string, len(*in))
		for key, val := range *in {
			var outVal *[]string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new([]string)
				if **in != nil {
					in, out := *in, *out
					*out = make([]string, len(*in))
					copy(*out, *in)
				}
			}
			(*out)[key] = outVal
		}
	}
	if in.Struct != nil {
		in, out := &in.Struct, &out.Struct
		*out = make(map[string]Ttest, len(*in))
		for key, val := range *in {
			(*out)[key] = *val.DeepCopy()
		}
	}
	if in.StructPtr != nil {
		in, out := &in.StructPtr, &out.StructPtr
		*out = make(map[string]*Ttest, len(*in))
		for key, val := range *in {
			var outVal *Ttest
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(Ttest)
				(*in).DeepCopyInto(*out)
			}
			(*out)[key] = outVal
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TestMaps.
func (in *TestMaps) DeepCopy() *TestMaps {
	if in == nil {
		return nil
	}
	out := new(TestMaps)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TestPointers) DeepCopyInto(out *TestPointers) {
	*out = *in
	if in.Builtin != nil {
		in, out := &in.Builtin, &out.Builtin
		*out = new(string)
		**out = **in
	}
	if in.Ptr != nil {
		in, out := &in.Ptr, &out.Ptr
		*out = new(*string)
		if **in != nil {
			in, out := *in, *out
			*out = new(string)
			**out = **in
		}
	}
	if in.Map != nil {
		in, out := &in.Map, &out.Map
		*out = new(map[string]string)
		if **in != nil {
			in, out := *in, *out
			*out = make(map[string]string, len(*in))
			for key, val := range *in {
				(*out)[key] = val
			}
		}
	}
	if in.Slice != nil {
		in, out := &in.Slice, &out.Slice
		*out = new([]string)
		if **in != nil {
			in, out := *in, *out
			*out = make([]string, len(*in))
			copy(*out, *in)
		}
	}
	if in.MapPtr != nil {
		in, out := &in.MapPtr, &out.MapPtr
		*out = new(*map[string]string)
		if **in != nil {
			in, out := *in, *out
			*out = new(map[string]string)
			if **in != nil {
				in, out := *in, *out
				*out = make(map[string]string, len(*in))
				for key, val := range *in {
					(*out)[key] = val
				}
			}
		}
	}
	if in.SlicePtr != nil {
		in, out := &in.SlicePtr, &out.SlicePtr
		*out = new(*[]string)
		if **in != nil {
			in, out := *in, *out
			*out = new([]string)
			if **in != nil {
				in, out := *in, *out
				*out = make([]string, len(*in))
				copy(*out, *in)
			}
		}
	}
	if in.Struct != nil {
		in, out := &in.Struct, &out.Struct
		*out = new(Ttest)
		(*in).DeepCopyInto(*out)
	}
	if in.StructPtr != nil {
		in, out := &in.StructPtr, &out.StructPtr
		*out = new(*Ttest)
		if **in != nil {
			in, out := *in, *out
			*out = new(Ttest)
			(*in).DeepCopyInto(*out)
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TestPointers.
func (in *TestPointers) DeepCopy() *TestPointers {
	if in == nil {
		return nil
	}
	out := new(TestPointers)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TestSlices) DeepCopyInto(out *TestSlices) {
	*out = *in
	if in.Byte != nil {
		in, out := &in.Byte, &out.Byte
		*out = make([]byte, len(*in))
		copy(*out, *in)
	}
	if in.Int8 != nil {
		in, out := &in.Int8, &out.Int8
		*out = make([]int8, len(*in))
		copy(*out, *in)
	}
	if in.Int16 != nil {
		in, out := &in.Int16, &out.Int16
		*out = make([]int16, len(*in))
		copy(*out, *in)
	}
	if in.Int32 != nil {
		in, out := &in.Int32, &out.Int32
		*out = make([]int32, len(*in))
		copy(*out, *in)
	}
	if in.Int64 != nil {
		in, out := &in.Int64, &out.Int64
		*out = make([]int64, len(*in))
		copy(*out, *in)
	}
	if in.Uint8 != nil {
		in, out := &in.Uint8, &out.Uint8
		*out = make([]uint8, len(*in))
		copy(*out, *in)
	}
	if in.Uint16 != nil {
		in, out := &in.Uint16, &out.Uint16
		*out = make([]uint16, len(*in))
		copy(*out, *in)
	}
	if in.Uint32 != nil {
		in, out := &in.Uint32, &out.Uint32
		*out = make([]uint32, len(*in))
		copy(*out, *in)
	}
	if in.Uint64 != nil {
		in, out := &in.Uint64, &out.Uint64
		*out = make([]uint64, len(*in))
		copy(*out, *in)
	}
	if in.Float32 != nil {
		in, out := &in.Float32, &out.Float32
		*out = make([]float32, len(*in))
		copy(*out, *in)
	}
	if in.Float64 != nil {
		in, out := &in.Float64, &out.Float64
		*out = make([]float64, len(*in))
		copy(*out, *in)
	}
	if in.String != nil {
		in, out := &in.String, &out.String
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.StringPtr != nil {
		in, out := &in.StringPtr, &out.StringPtr
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.StringPtrPtr != nil {
		in, out := &in.StringPtrPtr, &out.StringPtrPtr
		*out = make([]**string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(*string)
				if **in != nil {
					in, out := *in, *out
					*out = new(string)
					**out = **in
				}
			}
		}
	}
	if in.Map != nil {
		in, out := &in.Map, &out.Map
		*out = make([]map[string]string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = make(map[string]string, len(*in))
				for key, val := range *in {
					(*out)[key] = val
				}
			}
		}
	}
	if in.MapPtr != nil {
		in, out := &in.MapPtr, &out.MapPtr
		*out = make([]*map[string]string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(map[string]string)
				if **in != nil {
					in, out := *in, *out
					*out = make(map[string]string, len(*in))
					for key, val := range *in {
						(*out)[key] = val
					}
				}
			}
		}
	}
	if in.Slice != nil {
		in, out := &in.Slice, &out.Slice
		*out = make([][]string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = make([]string, len(*in))
				copy(*out, *in)
			}
		}
	}
	if in.SlicePtr != nil {
		in, out := &in.SlicePtr, &out.SlicePtr
		*out = make([]*[]string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new([]string)
				if **in != nil {
					in, out := *in, *out
					*out = make([]string, len(*in))
					copy(*out, *in)
				}
			}
		}
	}
	if in.Struct != nil {
		in, out := &in.Struct, &out.Struct
		*out = make([]Ttest, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.StructPtr != nil {
		in, out := &in.StructPtr, &out.StructPtr
		*out = make([]*Ttest, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(Ttest)
				(*in).DeepCopyInto(*out)
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TestSlices.
func (in *TestSlices) DeepCopy() *TestSlices {
	if in == nil {
		return nil
	}
	out := new(TestSlices)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Ttest) DeepCopyInto(out *Ttest) {
	*out = *in
	if in.Slice != nil {
		in, out := &in.Slice, &out.Slice
		*out = make(Slice, len(*in))
		copy(*out, *in)
	}
	if in.Pointer != nil {
		in, out := &in.Pointer, &out.Pointer
		*out = new(int)
		**out = **in
	}
	if in.PointerAlias != nil {
		in, out := &in.PointerAlias, &out.PointerAlias
		*out = new(Builtin)
		**out = **in
	}
	out.Struct = in.Struct
	if in.Map != nil {
		in, out := &in.Map, &out.Map
		*out = make(Map, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SliceSlice != nil {
		in, out := &in.SliceSlice, &out.SliceSlice
		*out = make([]Slice, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = make(Slice, len(*in))
				copy(*out, *in)
			}
		}
	}
	if in.MapSlice != nil {
		in, out := &in.MapSlice, &out.MapSlice
		*out = make(map[string]Slice, len(*in))
		for key, val := range *in {
			var outVal []int
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = make(Slice, len(*in))
				copy(*out, *in)
			}
			(*out)[key] = outVal
		}
	}
	out.FooAlias = in.FooAlias
	if in.FooSlice != nil {
		in, out := &in.FooSlice, &out.FooSlice
		*out = make(FooSlice, len(*in))
		copy(*out, *in)
	}
	if in.FooPointer != nil {
		in, out := &in.FooPointer, &out.FooPointer
		*out = new(Foo)
		**out = **in
	}
	if in.FooMap != nil {
		in, out := &in.FooMap, &out.FooMap
		*out = make(FooMap, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.AliasSlice != nil {
		in, out := &in.AliasSlice, &out.AliasSlice
		*out = make(AliasSlice, len(*in))
		copy(*out, *in)
	}
	if in.AliasPointer != nil {
		in, out := &in.AliasPointer, &out.AliasPointer
		*out = new(int)
		**out = **in
	}
	out.AliasStruct = in.AliasStruct
	if in.AliasMap != nil {
		in, out := &in.AliasMap, &out.AliasMap
		*out = make(AliasMap, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Ttest.
func (in *Ttest) DeepCopy() *Ttest {
	if in == nil {
		return nil
	}
	out := new(Ttest)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *UntypedBlob) DeepCopyInto(out *UntypedBlob) {
	*out = *in
	if in.raw != nil {
		in, out := &in.raw, &out.raw
		*out = make(json.RawMessage, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new UntypedBlob.
func (in *UntypedBlob) DeepCopy() *UntypedBlob {
	if in == nil {
		return nil
	}
	out := new(UntypedBlob)
	in.DeepCopyInto(out)
	return out
}
