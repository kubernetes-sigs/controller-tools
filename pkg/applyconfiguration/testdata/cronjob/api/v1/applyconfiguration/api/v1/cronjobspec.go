// Code generated by applyconfiguration. DO NOT EDIT.

package v1

import (
	v1beta1 "k8s.io/api/batch/v1beta1"
	corev1 "k8s.io/api/core/v1"
	runtime "k8s.io/apimachinery/pkg/runtime"
	intstr "k8s.io/apimachinery/pkg/util/intstr"
	apiv1 "sigs.k8s.io/controller-tools/pkg/applyconfiguration/testdata/cronjob/api/v1"
)

// CronJobSpecApplyConfiguration represents a declarative configuration of the CronJobSpec type for use
// with apply.
//
// CronJobSpec defines the desired state of CronJob
type CronJobSpecApplyConfiguration struct {
	// The schedule in Cron format, see https://en.wikipedia.org/wiki/Cron.
	Schedule *string `json:"schedule,omitempty"`
	// Optional deadline in seconds for starting the job if it misses scheduled
	// time for any reason.  Missed jobs executions will be counted as failed ones.
	StartingDeadlineSeconds *int64 `json:"startingDeadlineSeconds,omitempty"`
	// Specifies how to treat concurrent executions of a Job.
	// Valid values are:
	// - "Allow" (default): allows CronJobs to run concurrently;
	// - "Forbid": forbids concurrent runs, skipping next run if previous run hasn't finished yet;
	// - "Replace": cancels currently running job and replaces it with a new one
	ConcurrencyPolicy *apiv1.ConcurrencyPolicy `json:"concurrencyPolicy,omitempty"`
	// This flag tells the controller to suspend subsequent executions, it does
	// not apply to already started executions.  Defaults to false.
	Suspend *bool `json:"suspend,omitempty"`
	// This flag is like suspend, but for when you really mean it.
	// It helps test the +kubebuilder:validation:Type marker.
	NoReallySuspend *apiv1.TotallyABool `json:"noReallySuspend,omitempty"`
	// This tests byte slice schema generation.
	BinaryName []byte `json:"binaryName,omitempty"`
	// This tests that nullable works correctly
	CanBeNull *string `json:"canBeNull,omitempty"`
	// Specifies the job that will be created when executing a CronJob.
	JobTemplate *v1beta1.JobTemplateSpec `json:"jobTemplate,omitempty"`
	// The number of successful finished jobs to retain.
	// This is a pointer to distinguish between explicit zero and not specified.
	SuccessfulJobsHistoryLimit *int32 `json:"successfulJobsHistoryLimit,omitempty"`
	// The number of failed finished jobs to retain.
	// This is a pointer to distinguish between explicit zero and not specified.
	FailedJobsHistoryLimit *int32 `json:"failedJobsHistoryLimit,omitempty"`
	// This tests byte slices are allowed as map values.
	ByteSliceData map[string][]byte `json:"byteSliceData,omitempty"`
	// This tests string slices are allowed as map values.
	StringSliceData map[string][]string `json:"stringSliceData,omitempty"`
	// This tests pointers are allowed as map values.
	PtrData map[string]*string `json:"ptrData,omitempty"`
	// This tests that markers that are allowed on both fields and types are applied to fields
	TwoOfAKindPart0 *string `json:"twoOfAKindPart0,omitempty"`
	// This tests that markers that are allowed on both fields and types are applied to types
	TwoOfAKindPart1 *apiv1.LongerString `json:"twoOfAKindPart1,omitempty"`
	// This tests that primitive defaulting can be performed.
	DefaultedString *string `json:"defaultedString,omitempty"`
	// This tests that slice defaulting can be performed.
	DefaultedSlice []string `json:"defaultedSlice,omitempty"`
	// This tests that slice and object defaulting can be performed.
	DefaultedObject []RootObjectApplyConfiguration `json:"defaultedObject,omitempty"`
	// This tests that empty slice defaulting can be performed.
	DefaultedEmptySlice []string `json:"defaultedEmptySlice,omitempty"`
	// This tests that an empty object defaulting can be performed on a map.
	DefaultedEmptyMap map[string]string `json:"defaultedEmptyMap,omitempty"`
	// This tests that an empty object defaulting can be performed on an object.
	DefaultedEmptyObject *EmpiableObjectApplyConfiguration `json:"defaultedEmptyObject,omitempty"`
	// This tests that kubebuilder defaulting takes precedence.
	DoubleDefaultedString *string `json:"doubleDefaultedString,omitempty"`
	// This tests that primitive defaulting can be performed.
	KubernetesDefaultedString *string `json:"kubernetesDefaultedString,omitempty"`
	// This tests that slice defaulting can be performed.
	KubernetesDefaultedSlice []string `json:"kubernetesDefaultedSlice,omitempty"`
	// This tests that slice and object defaulting can be performed.
	KubernetesDefaultedObject []RootObjectApplyConfiguration `json:"kubernetesDefaultedObject,omitempty"`
	// This tests that empty slice defaulting can be performed.
	KubernetesDefaultedEmptySlice []string `json:"kubernetesDefaultedEmptySlice,omitempty"`
	// This tests that an empty object defaulting can be performed on a map.
	KubernetesDefaultedEmptyMap map[string]string `json:"kubernetesDefaultedEmptyMap,omitempty"`
	// This tests that an empty object defaulting can be performed on an object.
	KubernetesDefaultedEmptyObject *EmpiableObjectApplyConfiguration `json:"kubernetesDefaultedEmptyObject,omitempty"`
	// This tests that use of +default=ref(...) doesn't break generation
	KubernetesDefaultedRef *string `json:"kubernetesDefaultedRef,omitempty"`
	// This tests that pattern validator is properly applied.
	PatternObject            *string                         `json:"patternObject,omitempty"`
	EmbeddedResource         *runtime.RawExtension           `json:"embeddedResource,omitempty"`
	UnprunedJSON             *NestedObjectApplyConfiguration `json:"unprunedJSON,omitempty"`
	UnprunedEmbeddedResource *runtime.RawExtension           `json:"unprunedEmbeddedResource,omitempty"`
	// This tests that a type-level pruning marker works.
	UnprunedFromType *PreservedApplyConfiguration `json:"unprunedFomType,omitempty"`
	// This tests that a type-level pruning marker combined with a field-level pruning marker works.
	UnprunedFromTypeAndField *PreservedApplyConfiguration `json:"unprunedFomTypeAndField,omitempty"`
	// This tests that associative lists work.
	AssociativeList []AssociativeTypeApplyConfiguration `json:"associativeList,omitempty"`
	// This tests that associative lists work via a nested type.
	NestedAssociativeList *apiv1.NestedAssociativeList `json:"nestedassociativeList,omitempty"`
	// A map that allows different actors to manage different fields
	MapOfInfo map[string][]byte `json:"mapOfInfo,omitempty"`
	// A map that allows different actors to manage different fields via a nested type.
	NestedMapOfInfo *apiv1.NestedMapOfInfo `json:"nestedMapOfInfo,omitempty"`
	// A struct that can only be entirely replaced
	StructWithSeveralFields *NestedObjectApplyConfiguration `json:"structWithSeveralFields,omitempty"`
	// A struct that can only be entirely replaced via a nested type.
	NestedStructWithSeveralFields *NestedStructWithSeveralFieldsApplyConfiguration `json:"nestedStructWithSeveralFields,omitempty"`
	// A struct that can only be entirely replaced via a nested type and
	// field markers.
	NestedStructWithSeveralFieldsDoubleMarked *NestedStructWithSeveralFieldsApplyConfiguration `json:"nestedStructWithSeveralFieldsDoubleMarked,omitempty"`
	// This tests that type references are properly flattened
	JustNestedObject *JustNestedObjectApplyConfiguration `json:"justNestedObject,omitempty"`
	// This tests explicitly optional kubebuilder fields
	ExplicitlyOptionalKubebuilder *string `json:"explicitlyOptionalKubebuilder,omitempty"`
	// This tests explicitly optional kubernetes fields
	ExplicitlyOptionalKubernetes *string `json:"explicitlyOptionalKubernetes,omitempty"`
	// This tests explicitly required kubebuilder fields
	ExplicitlyRequiredKubebuilder *string `json:"explicitlyRequiredKubebuilder,omitempty"`
	// This tests explicitly required kubernetes fields
	ExplicitlyRequiredKubernetes *string `json:"explicitlyRequiredKubernetes,omitempty"`
	// This tests that min/max properties work
	MinMaxProperties *MinMaxObjectApplyConfiguration `json:"minMaxProperties,omitempty"`
	// This tests that the schemaless marker works
	Schemaless []byte `json:"schemaless,omitempty"`
	// This tests that an IntOrString can also have string validation.
	// This can be useful if you want to limit the string to a percentage or integer.
	// The XIntOrString marker is a requirement for having a pattern on this type.
	IntOrStringWithAPattern *intstr.IntOrString `json:"intOrStringWithAPattern,omitempty"`
	// Checks that nested maps work
	NestedMap map[string]map[string]string `json:"nestedMap,omitempty"`
	// Checks that multiply-nested maps work
	NestedNestedMap map[string]map[string]map[string]string `json:"nestedNestedMap,omitempty"`
	// Checks that maps containing types that contain maps work
	ContainsNestedMapMap map[string]ContainsNestedMapApplyConfiguration `json:"nestedMapInStruct,omitempty"`
	// Maps of arrays of things-that-arenâ€™t-strings are permitted
	MapOfArraysOfFloats    map[string][]bool `json:"mapOfArraysOfFloats,omitempty"`
	FloatWithValidations   *float64          `json:"floatWithValidations,omitempty"`
	Float64WithValidations *float64          `json:"float64WithValidations,omitempty"`
	IntWithValidations     *int              `json:"intWithValidations,omitempty"`
	Int32WithValidations   *int32            `json:"int32WithValidations,omitempty"`
	// This tests that both unexported and exported inline fields are not skipped in the schema generation
	//
	// This currently does not work
	// unexportedStruct `json:",inline"`
	ExportedStructApplyConfiguration `json:",inline"`
	// Test of the expression-based validation rule marker, with optional message.
	StringWithEvenLength *string `json:"stringWithEvenLength,omitempty"`
	// Test of the expression-based validation with messageExpression marker.
	StringWithEvenLengthAndMessageExpression *string `json:"stringWithEvenLengthAndMessageExpression,omitempty"`
	// Test of the expression-based validation on both field and type.
	StringWithEvenLengthAndGoodPrefix *apiv1.StringEvenType `json:"stringWithEvenLengthAndGoodPrefix,omitempty"`
	// Test that we can add a forbidden field using XValidation Reason and FieldPath.
	// The validation is applied to the spec struct itself and not the field.
	ForbiddenInt *int `json:"forbiddenInt,omitempty"`
	// Checks that fixed-length arrays work
	Array *[3]int `json:"array,omitempty"`
	// Checks that arrays work when the type contains a composite literal
	ArrayUsingCompositeLiteral *[3]string `json:"arrayUsingCompositeLiteral,omitempty"`
	// This tests string slice item validation.
	Hosts []string `json:"hosts,omitempty"`
	// This tests slice item validation with enum
	EnumSlice  []int        `json:"enumSlice,omitempty"`
	HostsAlias *apiv1.Hosts `json:"hostsAlias,omitempty"`
	// This tests that alias imported from a package is handled correctly. The
	// corev1.IPFamilyPolicyType is just reused since it's available from
	// imported package. We can create our own in a separate package if needed.
	AliasFromPackage *corev1.IPFamilyPolicy `json:"aliasFromPackage,omitempty"`
	// This tests that string alias is handled correctly.
	StringAlias    *string `json:"stringAlias,omitempty"`
	StringAliasPtr *string `json:"stringAliasPtr,omitempty"`
	// This tests that validation on a string alias type is handled correctly.
	StringAliasAddedValidation *string `json:"stringAliasAddedValidation,omitempty"`
	// This tests that validation on a the string alias type itself is handled correctly.
	StringAliasAlreadyValidated *string `json:"stringAliasAlreadyValidated,omitempty"`
	// This tests string slice validation.
	StringPair []string `json:"stringPair,omitempty"`
	// This tests string alias slice item validation.
	LongerStringArray []apiv1.LongerString `json:"longerStringArray,omitempty"`
	// This tests that we can embed protocol correctly (without ending up with allOf).
	// Context: https://github.com/kubernetes-sigs/controller-tools/issues/1027
	// Defaults to "TCP".
	Protocol *corev1.Protocol `json:"protocol,omitempty"`
	// This tests that selectable field.
	SelectableFieldString *string `json:"selectableFieldString,omitempty"`
	// This tests that embedded struct, which is an alias type, is handled correctly.
	EmbeddedStructApplyConfiguration `json:",inline"`
	// Test that we can add a field that can only be set to a non-default value on updates using XValidation OptionalOldSelf.
	OnlyAllowSettingOnUpdate *int32 `json:"onlyAllowSettingOnUpdate,omitempty"`
}

// CronJobSpecApplyConfiguration constructs a declarative configuration of the CronJobSpec type for use with
// apply.
func CronJobSpec() *CronJobSpecApplyConfiguration {
	return &CronJobSpecApplyConfiguration{}
}

// WithSchedule sets the Schedule field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Schedule field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithSchedule(value string) *CronJobSpecApplyConfiguration {
	b.Schedule = &value
	return b
}

// WithStartingDeadlineSeconds sets the StartingDeadlineSeconds field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the StartingDeadlineSeconds field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithStartingDeadlineSeconds(value int64) *CronJobSpecApplyConfiguration {
	b.StartingDeadlineSeconds = &value
	return b
}

// WithConcurrencyPolicy sets the ConcurrencyPolicy field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ConcurrencyPolicy field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithConcurrencyPolicy(value apiv1.ConcurrencyPolicy) *CronJobSpecApplyConfiguration {
	b.ConcurrencyPolicy = &value
	return b
}

// WithSuspend sets the Suspend field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Suspend field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithSuspend(value bool) *CronJobSpecApplyConfiguration {
	b.Suspend = &value
	return b
}

// WithNoReallySuspend sets the NoReallySuspend field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the NoReallySuspend field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithNoReallySuspend(value apiv1.TotallyABool) *CronJobSpecApplyConfiguration {
	b.NoReallySuspend = &value
	return b
}

// WithBinaryName adds the given value to the BinaryName field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the BinaryName field.
func (b *CronJobSpecApplyConfiguration) WithBinaryName(values ...byte) *CronJobSpecApplyConfiguration {
	for i := range values {
		b.BinaryName = append(b.BinaryName, values[i])
	}
	return b
}

// WithCanBeNull sets the CanBeNull field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the CanBeNull field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithCanBeNull(value string) *CronJobSpecApplyConfiguration {
	b.CanBeNull = &value
	return b
}

// WithJobTemplate sets the JobTemplate field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the JobTemplate field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithJobTemplate(value v1beta1.JobTemplateSpec) *CronJobSpecApplyConfiguration {
	b.JobTemplate = &value
	return b
}

// WithSuccessfulJobsHistoryLimit sets the SuccessfulJobsHistoryLimit field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the SuccessfulJobsHistoryLimit field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithSuccessfulJobsHistoryLimit(value int32) *CronJobSpecApplyConfiguration {
	b.SuccessfulJobsHistoryLimit = &value
	return b
}

// WithFailedJobsHistoryLimit sets the FailedJobsHistoryLimit field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the FailedJobsHistoryLimit field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithFailedJobsHistoryLimit(value int32) *CronJobSpecApplyConfiguration {
	b.FailedJobsHistoryLimit = &value
	return b
}

// WithByteSliceData puts the entries into the ByteSliceData field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, the entries provided by each call will be put on the ByteSliceData field,
// overwriting an existing map entries in ByteSliceData field with the same key.
func (b *CronJobSpecApplyConfiguration) WithByteSliceData(entries map[string][]byte) *CronJobSpecApplyConfiguration {
	if b.ByteSliceData == nil && len(entries) > 0 {
		b.ByteSliceData = make(map[string][]byte, len(entries))
	}
	for k, v := range entries {
		b.ByteSliceData[k] = v
	}
	return b
}

// WithStringSliceData puts the entries into the StringSliceData field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, the entries provided by each call will be put on the StringSliceData field,
// overwriting an existing map entries in StringSliceData field with the same key.
func (b *CronJobSpecApplyConfiguration) WithStringSliceData(entries map[string][]string) *CronJobSpecApplyConfiguration {
	if b.StringSliceData == nil && len(entries) > 0 {
		b.StringSliceData = make(map[string][]string, len(entries))
	}
	for k, v := range entries {
		b.StringSliceData[k] = v
	}
	return b
}

// WithPtrData puts the entries into the PtrData field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, the entries provided by each call will be put on the PtrData field,
// overwriting an existing map entries in PtrData field with the same key.
func (b *CronJobSpecApplyConfiguration) WithPtrData(entries map[string]*string) *CronJobSpecApplyConfiguration {
	if b.PtrData == nil && len(entries) > 0 {
		b.PtrData = make(map[string]*string, len(entries))
	}
	for k, v := range entries {
		b.PtrData[k] = v
	}
	return b
}

// WithTwoOfAKindPart0 sets the TwoOfAKindPart0 field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the TwoOfAKindPart0 field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithTwoOfAKindPart0(value string) *CronJobSpecApplyConfiguration {
	b.TwoOfAKindPart0 = &value
	return b
}

// WithTwoOfAKindPart1 sets the TwoOfAKindPart1 field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the TwoOfAKindPart1 field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithTwoOfAKindPart1(value apiv1.LongerString) *CronJobSpecApplyConfiguration {
	b.TwoOfAKindPart1 = &value
	return b
}

// WithDefaultedString sets the DefaultedString field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the DefaultedString field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithDefaultedString(value string) *CronJobSpecApplyConfiguration {
	b.DefaultedString = &value
	return b
}

// WithDefaultedSlice adds the given value to the DefaultedSlice field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the DefaultedSlice field.
func (b *CronJobSpecApplyConfiguration) WithDefaultedSlice(values ...string) *CronJobSpecApplyConfiguration {
	for i := range values {
		b.DefaultedSlice = append(b.DefaultedSlice, values[i])
	}
	return b
}

// WithDefaultedObject adds the given value to the DefaultedObject field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the DefaultedObject field.
func (b *CronJobSpecApplyConfiguration) WithDefaultedObject(values ...*RootObjectApplyConfiguration) *CronJobSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithDefaultedObject")
		}
		b.DefaultedObject = append(b.DefaultedObject, *values[i])
	}
	return b
}

// WithDefaultedEmptySlice adds the given value to the DefaultedEmptySlice field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the DefaultedEmptySlice field.
func (b *CronJobSpecApplyConfiguration) WithDefaultedEmptySlice(values ...string) *CronJobSpecApplyConfiguration {
	for i := range values {
		b.DefaultedEmptySlice = append(b.DefaultedEmptySlice, values[i])
	}
	return b
}

// WithDefaultedEmptyMap puts the entries into the DefaultedEmptyMap field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, the entries provided by each call will be put on the DefaultedEmptyMap field,
// overwriting an existing map entries in DefaultedEmptyMap field with the same key.
func (b *CronJobSpecApplyConfiguration) WithDefaultedEmptyMap(entries map[string]string) *CronJobSpecApplyConfiguration {
	if b.DefaultedEmptyMap == nil && len(entries) > 0 {
		b.DefaultedEmptyMap = make(map[string]string, len(entries))
	}
	for k, v := range entries {
		b.DefaultedEmptyMap[k] = v
	}
	return b
}

// WithDefaultedEmptyObject sets the DefaultedEmptyObject field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the DefaultedEmptyObject field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithDefaultedEmptyObject(value *EmpiableObjectApplyConfiguration) *CronJobSpecApplyConfiguration {
	b.DefaultedEmptyObject = value
	return b
}

// WithDoubleDefaultedString sets the DoubleDefaultedString field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the DoubleDefaultedString field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithDoubleDefaultedString(value string) *CronJobSpecApplyConfiguration {
	b.DoubleDefaultedString = &value
	return b
}

// WithKubernetesDefaultedString sets the KubernetesDefaultedString field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the KubernetesDefaultedString field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithKubernetesDefaultedString(value string) *CronJobSpecApplyConfiguration {
	b.KubernetesDefaultedString = &value
	return b
}

// WithKubernetesDefaultedSlice adds the given value to the KubernetesDefaultedSlice field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the KubernetesDefaultedSlice field.
func (b *CronJobSpecApplyConfiguration) WithKubernetesDefaultedSlice(values ...string) *CronJobSpecApplyConfiguration {
	for i := range values {
		b.KubernetesDefaultedSlice = append(b.KubernetesDefaultedSlice, values[i])
	}
	return b
}

// WithKubernetesDefaultedObject adds the given value to the KubernetesDefaultedObject field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the KubernetesDefaultedObject field.
func (b *CronJobSpecApplyConfiguration) WithKubernetesDefaultedObject(values ...*RootObjectApplyConfiguration) *CronJobSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithKubernetesDefaultedObject")
		}
		b.KubernetesDefaultedObject = append(b.KubernetesDefaultedObject, *values[i])
	}
	return b
}

// WithKubernetesDefaultedEmptySlice adds the given value to the KubernetesDefaultedEmptySlice field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the KubernetesDefaultedEmptySlice field.
func (b *CronJobSpecApplyConfiguration) WithKubernetesDefaultedEmptySlice(values ...string) *CronJobSpecApplyConfiguration {
	for i := range values {
		b.KubernetesDefaultedEmptySlice = append(b.KubernetesDefaultedEmptySlice, values[i])
	}
	return b
}

// WithKubernetesDefaultedEmptyMap puts the entries into the KubernetesDefaultedEmptyMap field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, the entries provided by each call will be put on the KubernetesDefaultedEmptyMap field,
// overwriting an existing map entries in KubernetesDefaultedEmptyMap field with the same key.
func (b *CronJobSpecApplyConfiguration) WithKubernetesDefaultedEmptyMap(entries map[string]string) *CronJobSpecApplyConfiguration {
	if b.KubernetesDefaultedEmptyMap == nil && len(entries) > 0 {
		b.KubernetesDefaultedEmptyMap = make(map[string]string, len(entries))
	}
	for k, v := range entries {
		b.KubernetesDefaultedEmptyMap[k] = v
	}
	return b
}

// WithKubernetesDefaultedEmptyObject sets the KubernetesDefaultedEmptyObject field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the KubernetesDefaultedEmptyObject field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithKubernetesDefaultedEmptyObject(value *EmpiableObjectApplyConfiguration) *CronJobSpecApplyConfiguration {
	b.KubernetesDefaultedEmptyObject = value
	return b
}

// WithKubernetesDefaultedRef sets the KubernetesDefaultedRef field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the KubernetesDefaultedRef field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithKubernetesDefaultedRef(value string) *CronJobSpecApplyConfiguration {
	b.KubernetesDefaultedRef = &value
	return b
}

// WithPatternObject sets the PatternObject field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the PatternObject field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithPatternObject(value string) *CronJobSpecApplyConfiguration {
	b.PatternObject = &value
	return b
}

// WithEmbeddedResource sets the EmbeddedResource field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the EmbeddedResource field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithEmbeddedResource(value runtime.RawExtension) *CronJobSpecApplyConfiguration {
	b.EmbeddedResource = &value
	return b
}

// WithUnprunedJSON sets the UnprunedJSON field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the UnprunedJSON field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithUnprunedJSON(value *NestedObjectApplyConfiguration) *CronJobSpecApplyConfiguration {
	b.UnprunedJSON = value
	return b
}

// WithUnprunedEmbeddedResource sets the UnprunedEmbeddedResource field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the UnprunedEmbeddedResource field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithUnprunedEmbeddedResource(value runtime.RawExtension) *CronJobSpecApplyConfiguration {
	b.UnprunedEmbeddedResource = &value
	return b
}

// WithUnprunedFromType sets the UnprunedFromType field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the UnprunedFromType field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithUnprunedFromType(value *PreservedApplyConfiguration) *CronJobSpecApplyConfiguration {
	b.UnprunedFromType = value
	return b
}

// WithUnprunedFromTypeAndField sets the UnprunedFromTypeAndField field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the UnprunedFromTypeAndField field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithUnprunedFromTypeAndField(value *PreservedApplyConfiguration) *CronJobSpecApplyConfiguration {
	b.UnprunedFromTypeAndField = value
	return b
}

// WithAssociativeList adds the given value to the AssociativeList field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the AssociativeList field.
func (b *CronJobSpecApplyConfiguration) WithAssociativeList(values ...*AssociativeTypeApplyConfiguration) *CronJobSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithAssociativeList")
		}
		b.AssociativeList = append(b.AssociativeList, *values[i])
	}
	return b
}

// WithNestedAssociativeList sets the NestedAssociativeList field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the NestedAssociativeList field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithNestedAssociativeList(value apiv1.NestedAssociativeList) *CronJobSpecApplyConfiguration {
	b.NestedAssociativeList = &value
	return b
}

// WithMapOfInfo puts the entries into the MapOfInfo field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, the entries provided by each call will be put on the MapOfInfo field,
// overwriting an existing map entries in MapOfInfo field with the same key.
func (b *CronJobSpecApplyConfiguration) WithMapOfInfo(entries map[string][]byte) *CronJobSpecApplyConfiguration {
	if b.MapOfInfo == nil && len(entries) > 0 {
		b.MapOfInfo = make(map[string][]byte, len(entries))
	}
	for k, v := range entries {
		b.MapOfInfo[k] = v
	}
	return b
}

// WithNestedMapOfInfo sets the NestedMapOfInfo field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the NestedMapOfInfo field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithNestedMapOfInfo(value apiv1.NestedMapOfInfo) *CronJobSpecApplyConfiguration {
	b.NestedMapOfInfo = &value
	return b
}

// WithStructWithSeveralFields sets the StructWithSeveralFields field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the StructWithSeveralFields field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithStructWithSeveralFields(value *NestedObjectApplyConfiguration) *CronJobSpecApplyConfiguration {
	b.StructWithSeveralFields = value
	return b
}

// WithNestedStructWithSeveralFields sets the NestedStructWithSeveralFields field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the NestedStructWithSeveralFields field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithNestedStructWithSeveralFields(value *NestedStructWithSeveralFieldsApplyConfiguration) *CronJobSpecApplyConfiguration {
	b.NestedStructWithSeveralFields = value
	return b
}

// WithNestedStructWithSeveralFieldsDoubleMarked sets the NestedStructWithSeveralFieldsDoubleMarked field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the NestedStructWithSeveralFieldsDoubleMarked field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithNestedStructWithSeveralFieldsDoubleMarked(value *NestedStructWithSeveralFieldsApplyConfiguration) *CronJobSpecApplyConfiguration {
	b.NestedStructWithSeveralFieldsDoubleMarked = value
	return b
}

// WithJustNestedObject sets the JustNestedObject field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the JustNestedObject field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithJustNestedObject(value *JustNestedObjectApplyConfiguration) *CronJobSpecApplyConfiguration {
	b.JustNestedObject = value
	return b
}

// WithExplicitlyOptionalKubebuilder sets the ExplicitlyOptionalKubebuilder field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ExplicitlyOptionalKubebuilder field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithExplicitlyOptionalKubebuilder(value string) *CronJobSpecApplyConfiguration {
	b.ExplicitlyOptionalKubebuilder = &value
	return b
}

// WithExplicitlyOptionalKubernetes sets the ExplicitlyOptionalKubernetes field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ExplicitlyOptionalKubernetes field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithExplicitlyOptionalKubernetes(value string) *CronJobSpecApplyConfiguration {
	b.ExplicitlyOptionalKubernetes = &value
	return b
}

// WithExplicitlyRequiredKubebuilder sets the ExplicitlyRequiredKubebuilder field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ExplicitlyRequiredKubebuilder field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithExplicitlyRequiredKubebuilder(value string) *CronJobSpecApplyConfiguration {
	b.ExplicitlyRequiredKubebuilder = &value
	return b
}

// WithExplicitlyRequiredKubernetes sets the ExplicitlyRequiredKubernetes field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ExplicitlyRequiredKubernetes field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithExplicitlyRequiredKubernetes(value string) *CronJobSpecApplyConfiguration {
	b.ExplicitlyRequiredKubernetes = &value
	return b
}

// WithMinMaxProperties sets the MinMaxProperties field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the MinMaxProperties field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithMinMaxProperties(value *MinMaxObjectApplyConfiguration) *CronJobSpecApplyConfiguration {
	b.MinMaxProperties = value
	return b
}

// WithSchemaless adds the given value to the Schemaless field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the Schemaless field.
func (b *CronJobSpecApplyConfiguration) WithSchemaless(values ...byte) *CronJobSpecApplyConfiguration {
	for i := range values {
		b.Schemaless = append(b.Schemaless, values[i])
	}
	return b
}

// WithIntOrStringWithAPattern sets the IntOrStringWithAPattern field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the IntOrStringWithAPattern field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithIntOrStringWithAPattern(value intstr.IntOrString) *CronJobSpecApplyConfiguration {
	b.IntOrStringWithAPattern = &value
	return b
}

// WithNestedMap puts the entries into the NestedMap field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, the entries provided by each call will be put on the NestedMap field,
// overwriting an existing map entries in NestedMap field with the same key.
func (b *CronJobSpecApplyConfiguration) WithNestedMap(entries map[string]map[string]string) *CronJobSpecApplyConfiguration {
	if b.NestedMap == nil && len(entries) > 0 {
		b.NestedMap = make(map[string]map[string]string, len(entries))
	}
	for k, v := range entries {
		b.NestedMap[k] = v
	}
	return b
}

// WithNestedNestedMap puts the entries into the NestedNestedMap field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, the entries provided by each call will be put on the NestedNestedMap field,
// overwriting an existing map entries in NestedNestedMap field with the same key.
func (b *CronJobSpecApplyConfiguration) WithNestedNestedMap(entries map[string]map[string]map[string]string) *CronJobSpecApplyConfiguration {
	if b.NestedNestedMap == nil && len(entries) > 0 {
		b.NestedNestedMap = make(map[string]map[string]map[string]string, len(entries))
	}
	for k, v := range entries {
		b.NestedNestedMap[k] = v
	}
	return b
}

// WithContainsNestedMapMap puts the entries into the ContainsNestedMapMap field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, the entries provided by each call will be put on the ContainsNestedMapMap field,
// overwriting an existing map entries in ContainsNestedMapMap field with the same key.
func (b *CronJobSpecApplyConfiguration) WithContainsNestedMapMap(entries map[string]ContainsNestedMapApplyConfiguration) *CronJobSpecApplyConfiguration {
	if b.ContainsNestedMapMap == nil && len(entries) > 0 {
		b.ContainsNestedMapMap = make(map[string]ContainsNestedMapApplyConfiguration, len(entries))
	}
	for k, v := range entries {
		b.ContainsNestedMapMap[k] = v
	}
	return b
}

// WithMapOfArraysOfFloats puts the entries into the MapOfArraysOfFloats field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, the entries provided by each call will be put on the MapOfArraysOfFloats field,
// overwriting an existing map entries in MapOfArraysOfFloats field with the same key.
func (b *CronJobSpecApplyConfiguration) WithMapOfArraysOfFloats(entries map[string][]bool) *CronJobSpecApplyConfiguration {
	if b.MapOfArraysOfFloats == nil && len(entries) > 0 {
		b.MapOfArraysOfFloats = make(map[string][]bool, len(entries))
	}
	for k, v := range entries {
		b.MapOfArraysOfFloats[k] = v
	}
	return b
}

// WithFloatWithValidations sets the FloatWithValidations field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the FloatWithValidations field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithFloatWithValidations(value float64) *CronJobSpecApplyConfiguration {
	b.FloatWithValidations = &value
	return b
}

// WithFloat64WithValidations sets the Float64WithValidations field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Float64WithValidations field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithFloat64WithValidations(value float64) *CronJobSpecApplyConfiguration {
	b.Float64WithValidations = &value
	return b
}

// WithIntWithValidations sets the IntWithValidations field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the IntWithValidations field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithIntWithValidations(value int) *CronJobSpecApplyConfiguration {
	b.IntWithValidations = &value
	return b
}

// WithInt32WithValidations sets the Int32WithValidations field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Int32WithValidations field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithInt32WithValidations(value int32) *CronJobSpecApplyConfiguration {
	b.Int32WithValidations = &value
	return b
}

// WithBaz sets the Baz field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Baz field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithBaz(value string) *CronJobSpecApplyConfiguration {
	b.ExportedStructApplyConfiguration.Baz = &value
	return b
}

// WithStringWithEvenLength sets the StringWithEvenLength field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the StringWithEvenLength field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithStringWithEvenLength(value string) *CronJobSpecApplyConfiguration {
	b.StringWithEvenLength = &value
	return b
}

// WithStringWithEvenLengthAndMessageExpression sets the StringWithEvenLengthAndMessageExpression field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the StringWithEvenLengthAndMessageExpression field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithStringWithEvenLengthAndMessageExpression(value string) *CronJobSpecApplyConfiguration {
	b.StringWithEvenLengthAndMessageExpression = &value
	return b
}

// WithStringWithEvenLengthAndGoodPrefix sets the StringWithEvenLengthAndGoodPrefix field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the StringWithEvenLengthAndGoodPrefix field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithStringWithEvenLengthAndGoodPrefix(value apiv1.StringEvenType) *CronJobSpecApplyConfiguration {
	b.StringWithEvenLengthAndGoodPrefix = &value
	return b
}

// WithForbiddenInt sets the ForbiddenInt field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ForbiddenInt field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithForbiddenInt(value int) *CronJobSpecApplyConfiguration {
	b.ForbiddenInt = &value
	return b
}

// WithArray sets the Array field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Array field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithArray(value [3]int) *CronJobSpecApplyConfiguration {
	b.Array = &value
	return b
}

// WithArrayUsingCompositeLiteral sets the ArrayUsingCompositeLiteral field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ArrayUsingCompositeLiteral field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithArrayUsingCompositeLiteral(value [3]string) *CronJobSpecApplyConfiguration {
	b.ArrayUsingCompositeLiteral = &value
	return b
}

// WithHosts adds the given value to the Hosts field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the Hosts field.
func (b *CronJobSpecApplyConfiguration) WithHosts(values ...string) *CronJobSpecApplyConfiguration {
	for i := range values {
		b.Hosts = append(b.Hosts, values[i])
	}
	return b
}

// WithEnumSlice adds the given value to the EnumSlice field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the EnumSlice field.
func (b *CronJobSpecApplyConfiguration) WithEnumSlice(values ...int) *CronJobSpecApplyConfiguration {
	for i := range values {
		b.EnumSlice = append(b.EnumSlice, values[i])
	}
	return b
}

// WithHostsAlias sets the HostsAlias field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the HostsAlias field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithHostsAlias(value apiv1.Hosts) *CronJobSpecApplyConfiguration {
	b.HostsAlias = &value
	return b
}

// WithAliasFromPackage sets the AliasFromPackage field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the AliasFromPackage field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithAliasFromPackage(value corev1.IPFamilyPolicy) *CronJobSpecApplyConfiguration {
	b.AliasFromPackage = &value
	return b
}

// WithStringAlias sets the StringAlias field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the StringAlias field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithStringAlias(value string) *CronJobSpecApplyConfiguration {
	b.StringAlias = &value
	return b
}

// WithStringAliasPtr sets the StringAliasPtr field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the StringAliasPtr field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithStringAliasPtr(value string) *CronJobSpecApplyConfiguration {
	b.StringAliasPtr = &value
	return b
}

// WithStringAliasAddedValidation sets the StringAliasAddedValidation field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the StringAliasAddedValidation field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithStringAliasAddedValidation(value string) *CronJobSpecApplyConfiguration {
	b.StringAliasAddedValidation = &value
	return b
}

// WithStringAliasAlreadyValidated sets the StringAliasAlreadyValidated field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the StringAliasAlreadyValidated field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithStringAliasAlreadyValidated(value string) *CronJobSpecApplyConfiguration {
	b.StringAliasAlreadyValidated = &value
	return b
}

// WithStringPair adds the given value to the StringPair field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the StringPair field.
func (b *CronJobSpecApplyConfiguration) WithStringPair(values ...string) *CronJobSpecApplyConfiguration {
	for i := range values {
		b.StringPair = append(b.StringPair, values[i])
	}
	return b
}

// WithLongerStringArray adds the given value to the LongerStringArray field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the LongerStringArray field.
func (b *CronJobSpecApplyConfiguration) WithLongerStringArray(values ...apiv1.LongerString) *CronJobSpecApplyConfiguration {
	for i := range values {
		b.LongerStringArray = append(b.LongerStringArray, values[i])
	}
	return b
}

// WithProtocol sets the Protocol field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Protocol field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithProtocol(value corev1.Protocol) *CronJobSpecApplyConfiguration {
	b.Protocol = &value
	return b
}

// WithSelectableFieldString sets the SelectableFieldString field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the SelectableFieldString field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithSelectableFieldString(value string) *CronJobSpecApplyConfiguration {
	b.SelectableFieldString = &value
	return b
}

// WithFromEmbedded sets the FromEmbedded field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the FromEmbedded field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithFromEmbedded(value string) *CronJobSpecApplyConfiguration {
	b.EmbeddedStructApplyConfiguration.FromEmbedded = &value
	return b
}

// WithOnlyAllowSettingOnUpdate sets the OnlyAllowSettingOnUpdate field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the OnlyAllowSettingOnUpdate field is set to the value of the last call.
func (b *CronJobSpecApplyConfiguration) WithOnlyAllowSettingOnUpdate(value int32) *CronJobSpecApplyConfiguration {
	b.OnlyAllowSettingOnUpdate = &value
	return b
}
